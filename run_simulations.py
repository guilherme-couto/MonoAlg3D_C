"""
Orchestration script for running cardiac electrophysiology simulations (MonoAlg3D)
with fibrosis patterns generated by an Octave script or pre-existing meshes.

This script manages the entire pipeline:
1. Sets up simulation parameters.
2. Checks for previously completed simulations to avoid redundant work.
3. Optionally generates fibrosis meshes (.alg files) using Octave.
4. Configures and runs the MonoAlg simulator.
5. Parses the results and logs them to a comprehensive CSV file.
"""
import os
import subprocess
import configparser
import logging
import argparse
from pathlib import Path
import numpy as np
import pandas as pd

# --- CONFIGURATION ---
# Use Path objects for robust path handling
CWD = Path.cwd()
OCTAVE_SCRIPT_DIR = CWD / "fibrosis_generator"
BASE_DIR = CWD / "chaos_paper_fibrotic_core_simulations" # Change this to your desired base directory
CONFIGS_PATH = BASE_DIR / "configs"
BASE_INI_PATH = CONFIGS_PATH / "base_simulation.ini"
MONOALG_EXECUTABLE = CWD / "bin" / "MonoAlg3D"
ATPI_VALUE = 2.0 # Change this to your desired atpi value
RESULTS_DIR = BASE_DIR / "results" / f"atpi_{ATPI_VALUE}"
ALG_MESHES_DIR = BASE_DIR / "alg_meshes"
SIM_OUTPUTS_DIR = RESULTS_DIR / "simulation_outputs"
ECGS_DIR = SIM_OUTPUTS_DIR / "ecg"
ANALYSIS_DIR = RESULTS_DIR / "analysis"
RESULTS_CSV_PATH = ANALYSIS_DIR / "simulation_results.csv"

# --- SIMULATION PARAMETERS ---
FIBROSIS_TYPES = {
    'compact': {
        'params': '[NaN, NaN, 0.44, 0.96, 0.59, 2.03, 2.47, {angle}]',
        'mode': 'threshold'
    },
    'interstitial': {
        'params': '[0.3, 0.31, 0.32, 0.24, 0.96, 4.67, 1.89, {angle}]',
        'mode': 'composition'
    },
    'diffuse': {
        'params': '[NaN, NaN, 0.49, 0.07, 0.44, 1.22, 2.17, {angle}]',
        'mode': 'composition'
    },
    'patchy': {
        'params': '[0.38, 0.31, 0.42, 0.32, 0.78, 2.1, 2.5, {angle}]',
        'mode': 'composition'
    }
}

# 100 seeds for reproducibility
SEEDS = [214, 483, 454, 163, 118, 139, 182, 22, 480, 451,
        449, 141, 364, 251, 487, 87, 164, 20, 80, 21,
        496, 369, 179, 176, 281, 111, 491, 333, 7, 309,
        407, 254, 340, 314, 190, 486, 125, 18, 452, 14,
        294, 109, 47, 404, 315, 401, 326, 239, 114, 51,
        238, 395, 160, 418, 434, 84, 378, 336, 285, 92,
        11, 244, 421, 497, 278, 13, 8, 405, 50, 191,
        137, 66, 97, 471, 478, 4, 53, 183, 341, 284,
        391, 127, 217, 55, 94, 415, 236, 437, 424, 392,
        489, 36, 174, 158, 290, 30, 300, 302, 126, 275]

# --- HELPER CLASSES AND FUNCTIONS ---

# Custom ConfigParser to preserve case sensitivity of keys
class CasePreservingConfigParser(configparser.ConfigParser):
    def optionxform(self, optionstr):
        return optionstr

def setup_logging():
    """Configures the logging system."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

def load_completed_simulations():
    """Loads the results CSV to check for completed simulations."""
    if not RESULTS_CSV_PATH.is_file():
        # Create file with header
        pd.DataFrame(columns=[
            'fibrosis_type', 'fiber_angle_deg', 'density', 'seed', 'atpi', 'creation_mode', 'final_time_ms'
        ]).to_csv(RESULTS_CSV_PATH, index=False)
    return pd.read_csv(RESULTS_CSV_PATH)

def is_simulation_done(df, params):
    """Checks if a simulation with the given parameters is already in the DataFrame."""
    query = ' & '.join(f'`{k}` == {v}' if isinstance(v, (int, float)) else f'`{k}` == "{v}"' for k, v in params.items())
    return not df.query(query).empty

def check_existing_meshes(fibrosis_type, angle_deg, densities):
    """
    Verifies that all expected .alg mesh files exist before running simulations.
    Returns True if all required meshes are found, False otherwise.
    """
    missing_files = []
    mesh_dir = ALG_MESHES_DIR / fibrosis_type
    for density in densities:
        for seed in SEEDS:
            mesh_file = mesh_dir / f"{fibrosis_type}_angle{angle_deg}_density{density:.2f}_seed{seed}.alg"
            if not mesh_file.is_file():
                missing_files.append(mesh_file)

    if missing_files:
        logging.error("Missing required meshes:")
        for f in missing_files[:10]:
            logging.error(f"  - {f.name}")
        if len(missing_files) > 10:
            logging.error(f"... and {len(missing_files)-10} more missing files.")
        logging.error("Aborting simulation batch. Please generate meshes or use --generate_mesh.")
        return False

    logging.info(f"All required meshes found in: {mesh_dir}")
    return True

def generate_fibrosis_mesh(octave_instance, f_type, f_params_str, angle_deg, density, seed, creation_mode):
    """Calls the Octave function to generate the fibrosis .alg file."""
    output_filename = f"{f_type}_angle{angle_deg}_density{density:.2f}_seed{seed}"
    output_path = ALG_MESHES_DIR / f_type
    output_path.mkdir(parents=True, exist_ok=True)

    full_output_path = output_path / output_filename
    final_mesh_path = full_output_path.with_suffix(full_output_path.suffix + ".alg")
    if final_mesh_path.exists():
        logging.info(f"Skipping mesh generation, it already exists at {final_mesh_path}")
        return str(final_mesh_path)

    logging.info(f"Generating mesh: {full_output_path.name}.alg")

    f_params_vec = octave_instance.eval(f_params_str)
    octave_instance.fibrosisPattern(
        f_params_vec,
        density,
        seed,
        creation_mode,
        str(full_output_path),
        True,   # save_mesh = true
        False,  # save_figure = false
        nout=0
    )

    return str(final_mesh_path)

def configure_and_run_simulation(mesh_path, sim_output_dir, atpi_value, domain_name):
    """Configures the .ini file and runs the MonoAlg3D simulation."""
    sim_output_dir.mkdir(parents=True, exist_ok=True)
    ini_path = CONFIGS_PATH / f"{sim_output_dir.name}.ini"

    # Create and configure the .ini file for this specific run
    config = CasePreservingConfigParser()
    config.read(BASE_INI_PATH)
    config['domain']['mesh_file'] = str(mesh_path)

    # The number of volumes is the number of lines in the .alg file
    # The discretization is in the fourth column (same for all volumes)
    # The number of extra fields is the line length without the the first 6 columns
    with open(mesh_path, 'r') as f:
        lines = f.readlines()
        num_volumes = len(lines)
        first_line = lines[0]
        half_dx = first_line.split(',')[3].strip()
        num_extra_fields = len(first_line.split(',')) - 6

    config['domain']['num_volumes'] = str(num_volumes)
    config['domain']['original_discretization'] = str(int(half_dx) * 2)
    config['domain']['num_extra_fields'] = str(num_extra_fields)
    config['domain']['name'] = domain_name
    config['save_result']['output_dir'] = str(sim_output_dir)
    config['extra_data']['atpi'] = str(atpi_value)

    ECGS_DIR.mkdir(parents=True, exist_ok=True)
    ecg_file_path = ECGS_DIR / f"ecg_{domain_name}.txt"
    config['calc_ecg']['filename'] = str(ecg_file_path)

    with open(ini_path, 'w') as configfile:
        config.write(configfile)

    # Execute the simulation
    logging.info(f"Running MonoAlg3D with config: {ini_path}")
    command = [str(MONOALG_EXECUTABLE), "-c", str(ini_path)]
    try:
        subprocess.run(command, check=True, capture_output=True, text=True)
        return parse_simulation_log(sim_output_dir)
    except subprocess.CalledProcessError as e:
        logging.error(f"MonoAlg3D simulation failed for {sim_output_dir.name}.")
        logging.error(f"Stderr: {e.stderr}")
        return -1.0

def parse_simulation_log(sim_output_dir):
    """Parses the outputlog.txt to find the last simulation time 't'."""
    log_file = sim_output_dir / "outputlog.txt"
    if not log_file.is_file():
        logging.warning(f"Log file not found: {log_file}")
        return -1.0

    last_t = 0.0
    with open(log_file, 'r') as f:
        for line in f:
            if line.startswith('t = '):
                try:
                    # Example line: t = 1000, Vm_max = 35.45
                    t_value = float(line.split(',')[0].split('=')[1].strip())
                    if t_value > last_t:
                        last_t = t_value
                except (IndexError, ValueError):
                    continue # Ignore malformed lines

    logging.info(f"Simulation finished. Final time: {last_t} ms.")
    return last_t

def run_simulation_batch(fibrosis_type, angle_deg, densities, atpi_val, generate_mesh):
    """Main function to orchestrate the simulation batch."""

    setup_logging()

    # Ensure all necessary directories exist
    for d in [ALG_MESHES_DIR, SIM_OUTPUTS_DIR, ANALYSIS_DIR]:
        d.mkdir(parents=True, exist_ok=True)

    completed_df = load_completed_simulations()
    new_results = []

    oc = None
    if generate_mesh:
        logging.info("Initializing Octave engine for mesh generation...")
        from oct2py import Oct2Py
        oc = Oct2Py()
        oc.addpath(str(OCTAVE_SCRIPT_DIR))
        logging.info("Octave engine ready.")
    else:
        logging.info("Mesh generation disabled. Checking for existing meshes...")
        if not check_existing_meshes(fibrosis_type, angle_deg, densities):
            return  # Abort early

    # --- MAIN LOOP ---
    f_type_info = FIBROSIS_TYPES[fibrosis_type]
    angle_rad = np.radians(angle_deg)
    creation_mode = f_type_info['mode']
    params_template = f_type_info['params']

    for density in densities:
        density = round(density, 2)
        for seed in SEEDS:
            # Check if this simulation has already been run
            sim_params = {
                'fibrosis_type': fibrosis_type,
                'fiber_angle_deg': angle_deg,
                'density': density,
                'seed': seed,
                'atpi': atpi_val,
                'creation_mode': creation_mode,
            }
            if is_simulation_done(completed_df, sim_params):
                logging.info(f"Skipping completed simulation: {fibrosis_type} angle={angle_deg} den={density} seed={seed}")
                continue

            logging.info(f"--- Starting new simulation: {fibrosis_type} angle={angle_deg} den={density} seed={seed} ---")

            mesh_file_path = ALG_MESHES_DIR / fibrosis_type / f"{fibrosis_type}_angle{angle_deg}_density{density:.2f}_seed{seed}.alg"
            if generate_mesh:
                current_params = params_template.format(angle=f"{angle_rad:.4f}")
                mesh_file_path = generate_fibrosis_mesh(oc, fibrosis_type, current_params, angle_deg, density, seed, creation_mode)
            else:
                logging.info(f"Using existing mesh: {mesh_file_path.name}")

            # Configure and Run MonoAlg Simulation
            sim_output_dir = SIM_OUTPUTS_DIR / f"{fibrosis_type}_angle{angle_deg}"
            domain_name = f"{fibrosis_type}_{creation_mode}_angle{angle_deg}_den{density}_seed{seed}_atpi{atpi_val}"
            final_time = configure_and_run_simulation(mesh_file_path, sim_output_dir, atpi_val, domain_name)

            # Log Result
            if final_time >= 0:
                result_data = sim_params.copy()
                result_data['final_time_ms'] = final_time
                new_results.append(result_data)
                pd.DataFrame([result_data]).to_csv(RESULTS_CSV_PATH, mode='a', header=False, index=False)
                logging.info(f"Result for seed {seed} logged successfully.")

    logging.info("Simulation batch finished.")

# --- SCRIPT ENTRY POINT ---
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run a batch of MonoAlg simulations for a specific fibrosis type and fiber angle.")

    parser.add_argument(
        "--ftype",
        type=str,
        required=True,
        choices=FIBROSIS_TYPES.keys(),
        help="The type of fibrosis to simulate."
    )
    parser.add_argument(
        "--angle",
        type=int,
        required=True,
        choices=[0, 30, 60, 90],
        help="The fiber orientation angle in degrees."
    )
    parser.add_argument(
        "--atpi",
        type=float,
        default=2.0,
        help="The 'atpi' value for the simulation configuration."
    )
    parser.add_argument(
        "--generate_mesh",
        action="store_true",
        help="Generate fibrosis meshes using Octave (default: False)."
    )

    # Define the density range to be simulated
    simulation_densities = np.arange(0.9, 0.0, -0.05)

    args = parser.parse_args()
    run_simulation_batch(
        fibrosis_type=args.ftype,
        angle_deg=args.angle,
        densities=simulation_densities,
        atpi_val=args.atpi,
        generate_mesh=args.generate_mesh
    )
