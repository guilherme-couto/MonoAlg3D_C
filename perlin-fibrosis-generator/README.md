# GNT Fibrosis Generator Framework
**High-Performance Cardiac Fibrosis Pattern Generator (2D & 3D)**

## 1. Overview
The **GNT Fibrosis Generator Framework** is a computational framework designed to create realistic cardiac fibrosis patterns for electrophysiological simulations. It operates on a **Geometry-Noise-Threshold** pipeline, decoupling the spatial definition of the fibrotic region from the textural generation of the fibrosis itself.

This design allows for massive scalability and efficiency, particularly when generating complex iterative patterns (like interstitial fibrosis) or performing sensitivity analyses on large datasets. The core engine is written in **GNU Octave** (MATLAB compatible) for high-speed matrix operations, orchestrated via **Python** for advanced visualization.

### 1.1 Scientific Basis
The textural patterns generated by this framework are based on **Perlin Noise**. Crucially, the noise parameters are derived from the work of **Lawson et al. (2024)**.

> *Reference:* Lawson, Brodie AJ, et al. "Perlin noise generation of physiologically realistic cardiac fibrosis." Medical Image Analysis 98 (2024): 103240. [DOI: 10.1016/j.media.2024.103240](https://doi.org/10.1016/j.media.2024.103240)

### 1.2 Project Lineage & Attribution

This framework is derived from and inspired by the original work presented in [`betalawson/perlin-microfibrosis`](https://github.com/betalawson/perlin-microfibrosis). The present implementation was significantly refactored and simplified to remove matching procedures, parameter optimization, and auxiliary components not required for direct pattern generation.

> **Attribution:** The base parameters were optimized by Lawson et al. to statistically reproduce fibrosis architectures observed in real histological cuts.

---

## 2. The GNT Architecture
The framework is built upon three modular pillars.

### **G - Geometry (The "Where")**
* **Responsibility:** Defines the spatial domain, the Fibrotic Core (FC), and the Border Zone (BZ) layers.
* **Logic:** Uses binary masks to define shapes.
    * **2D:** Ellipse, Rectangle, Full.
    * **3D:** Ellipsoid, Box, Full.
* **Optimization:** Utilizes the **Distance Transform of Binary Image (`bwdist`)** to calculate Border Zone layers instantly in any dimension. Geometry is calculated **once** and reused during iterative composition.

### **N - Noise (The "Texture")**
* **Responsibility:** Generates a normalized floating-point field $[0, 1]$ representing the tissue texture.
* **Logic:** Combines multi-octave Perlin noise with domain-specific modifiers.

### **T - Threshold (The "Decision")**
* **Responsibility:** Combines Geometry and Noise to create the final binary map.
* **Logic:**
    1.  **Core:** Uses a Bisection Method to find the exact noise threshold required to achieve the target density *within* the geometric core.
    2.  **Border Zone:** Applies a spatially varying gradient to the threshold, creating a smooth falloff from the core to healthy tissue.

---

## 3. Workflow & Visualization

The system entry point is `run_fibrosis_generator.m`. The pipeline is dimension-agnostic, handling 2D slices and 3D volumes seamlessly.

### 3.1 Advanced Visualization (Python Bridge)
The framework includes a powerful visualization module (`save_fibrosis_image.py`) that adapts to the data dimension:
* **2D Mode:** Generates static maps using **Matplotlib**.
* **3D Mode (Slices):** Generates an animated **GIF** traversing the Z-axis (slice-by-slice view).
* **3D Mode (Volumetric):** Uses **PyVista (VTK)** to render:
    * **Orthogonal Slices:** Intersecting X/Y/Z planes within the volume.
    * **Isosurface Render:** A 3D render of the fibrotic network (excluding healthy tissue) with realistic lighting.

### 3.2 Output Formats
* **ALG File:** A generic CSV-like format compatible with finite volume solvers (FVM). Includes coordinates, fiber vectors, and local fibrosis tags.
* **Images:** PNG and GIF visualisations.

---

## 4. Fibrosis Types
The generator supports four distinct phenotypes, physically modelled based on histological characteristics:

| Type | Mode | Description | Key Characteristics |
| :--- | :--- | :--- | :--- |
| **Compact** | Threshold | Dense, contiguous scarring entirely devoid of myocardial tissue. | Creates wide conduction blocks. |
| **Diffuse** | Composition | Short, scattered collagen segments dispersed throughout the myocardium. | Disrupts local wavefronts without forming large obstacles. |
| **Interstitial** | Composition | Fine, reticular mesh accumulating between cardiomyocyte clusters. | Separates fibers while preserving tissue continuity. |
| **Patchy** | Composition | Long, irregular strands interwoven deeply with myocardial bundles. | Creates a complex substrate with irregular clusters. |

---

## 5. Installation & Environment

This project relies on a hybrid **Octave/Python** environment. A robust Conda environment file is provided.

### 5.1 Prerequisites
* **Conda** (Miniforge or Anaconda).
* **GNU Octave** (Version 8.4.0 recommended).

### 5.2 Setting up the Environment
A ready-to-use `environment.yml` is provided in the root directory. To install:

```bash
conda env create -f environment.yml
conda activate gnt-env
```

**Key Dependencies included:**
* `python=3.12` (Required for PyVista stability)
* `octave=8.4.0`
* `pyvista` (3D Visualization)
* `matplotlib`, `scipy`, `numpy`

### 5.3 Compilation of C++ Sources
The project contains C++ files (`Octave2D.cpp`, `Octave3D.cpp`) that must be compiled into MEX files callable by Octave. These files utilize the "mex.h" header (MATLAB API style).

* **Build Tool:**
    * Use 'mkoctfile', which is provided by the Octave package in Conda.

* **Instructions:**
   1.  Activate the Conda environment.
   2.  Navigate to the directory containing the .cpp files.
   3.  Run the following commands to generate the binary MEX files:
        ```bash
        mkoctfile --mex Octave2D.cpp
        mkoctfile --mex Octave3D.cpp
        ```

* **Expected Output:**
    * This will generate files with extensions '.mex' (or '.mexa64'). These binaries are automatically detected by Octave as functions.

---

## 6. Quick Start & Examples

To verify the capabilities of the framework, run the included `run_examples.m` script. It automatically generates four distinct scenarios covering different fibrosis phenotypes and dimensions:

1.  **2D Diffuse (Full):** A 4x4cm slab with diffuse fibrosis.
2.  **2D Interstitial (Embedded):** An elliptical core of interstitial fibrosis within a healthy slab.
3.  **3D Patchy (Full):** A 1cm³ cube with patchy fibrosis.
4.  **3D Compact (Box):** A fibrotic box embedded within a larger tissue volume.

To execute the examples:

```bash
octave-cli run_examples.m
```

* **Expected Output:**
    * Console logs indicating the progress of each scenario.
    * A new folder `examples/` containing `.alg` meshes and `.png` visualizations for each scenario.

---

## 7. Usage

The core function of the framework is `run_fibrosis_generator`. It can be called directly from Octave or via a Python bridge.

### Function Signature
```matlab
run_fibrosis_generator(fibrosis_type, density, seed, angle, dim_mode, ...
                       domain_dims, shape, core_dims, output_name, ...
                       save_mesh, save_fig)
```

### Parameters

| Parameter | Type | Description | Example |
| :--- | :--- | :--- | :--- |
| **`fibrosis_type`** | String | The texture phenotype. Options: `'compact'`, `'interstitial'`, `'diffuse'`, `'patchy'`. | `'compact'` |
| **`density`** | Float | Target fibrosis density (0.0 to 1.0). | `0.4` |
| **`seed`** | Int | Random Number Generator seed for reproducibility. | `123` |
| **`angle`** | Mixed | Fiber orientation in degrees. <br>• **2D:** Scalar (e.g., `60`).<br>• **3D:** Vector `[Phi, Theta]` (e.g., `[0, 90]`). | `60` |
| **`dim_mode`** | String | Operational dimension. Options: `'2D'`, `'3D'`. | `'3D'` |
| **`domain_dims`** | Vector | Dimensions of the entire tissue domain (cm). <br>**Format:** `[dx, Lx, Ly, (Lz)]`. <br>*Note: `dx` is the spatial resolution.* | `[0.01, 2.0, 4.0]` |
| **`shape`** | String | Geometric shape of the fibrotic region.<br>• **2D:** `'ellipse'`, `'rectangle'`, `'full'`.<br>• **3D:** `'ellipsoid'`, `'box'`, `'full'`. | `'ellipse'` |
| **`core_dims`** | Vector | Dimensions of the fibrotic core (cm). Ignored if shape is `'full'`.<br>**Format:** `[width, height, (depth)]`. | `[1.0, 2.0]` |
| **`output_name`** | String | Full path and filename for output (without extension). | `'results/sim_01'` |
| **`save_mesh`** | Bool | If `true`, saves the Finite Volume Mesh (`.alg`). | `true` |
| **`save_fig`** | Bool | If `true`, delegates visualization to Python (PNG/GIF). | `true` |

**Note on Geometry:** The `core_dims` defines the region of maximum density (Fibrotic Core). The framework automatically calculates a **Border Zone** around this core based on its dimensions and simulation resolution `dx`.

---

## 8. Directory Structure

```text
/
│
├── environment.yml                 # Conda environment definition
├── run_examples.m                  # Quick start script
├── run_fibrosis_generator.m        # Main Entry point
├── save_fibrosis_image.py          # Python visualization utility (PyVista/Matplotlib)
│
├── /modules                        # Core GNT Logic
│   ├── applyFibrosisThreshold.m
│   ├── computeFibrosisGeometry.m
│   ├── computeNoiseField.m
│   ├── generateFibrosisWorkflow.m
│   ├── runCompositionLoop.m
│   ├── savePatternVisualisation.m
│   └── writeALGFromPatternData.m
│
└── /helpers                        # Math & Compilation
    ├── buildMesh.m
    ├── generateTables.m
    ├── Octave2D.cpp
    ├── Octave3D.cpp
    ├── Octave2D.mex                # Compiled Perlin 2D
    └── Octave3D.mex                # Compiled Perlin 3D
```
